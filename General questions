1. Что такое ООП? Полное определение
Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые содержат:

Данные (поля/атрибуты/свойства)

Поведение (методы/функции)

4 основных принципа ООП:

Инкапсуляция:

Сокрытие внутренней реализации

Пример: private поля с getters/setters
class BankAccount {
    private double balance;
    public double getBalance() { return this.balance; }
}
Наследование:

Создание новых классов на основе существующих

Пример: Класс Animal → классы Dog, Cat
class Animal:
    def speak(self): pass

class Dog(Animal):
    def speak(self): return "Woof!"
Полиморфизм:

Один интерфейс — разные реализации

Пример: Переопределение методов
def animal_sound(animals: List[Animal]):
    for animal in animals:
        print(animal.speak())  # Вызовет правильную реализацию
Абстракция:

Выделение существенных характеристик

Пример: Абстрактный класс Shape с методом area()
abstract class Shape {
    abstract double area();
}
Дополнительные концепции:

Композиция/агрегация

Ассоциация

Интерфейсы

Классы-наследники

2. Магическое число 7 Миллера: 7+ примеров из IT
Закон Миллера: Человек может одновременно удерживать в памяти 7±2 элемента.

Примеры в IT:

Лимит вкладок браузера:

Средний пользователь держит открытыми ~7 вкладок

Chrome даже показывает смайлик при открытии 8+ вкладок

Меню навигации:

Оптимальное количество пунктов главного меню — 5-9

Пример: GitHub (7 основных пунктов)

Аргументы функций:

Рекомендация: не более 7 параметров
# Плохо
def process_data(a, b, c, d, e, f, g, h, i):

# Хорошо
def process_data(config: ConfigObject):
Колонки в таблицах:

Для читаемости — не более 7-9 колонок

Пример: Excel/SQL-выводы с большим числом колонок сложны для восприятия

Группировка UI элементов:

Кнопки/иконки группируются по 5-9 элементов

Пример: Панель инструментов Photoshop (группы по 5-7 иконок)

Уровни вложенности кода:

Рекомендуемая глубина — не более 7
# Трудно читать
if ...:
    for ...:
        while ...:
            try ...:
                if ...:
                    for ...:
                        if ...:
Пункты выпадающих списков:

Оптимально 5-7 пунктов без скролла

Пример: Меню "Файл" в большинстве приложений

Число модулей в системе:

Микросервисные архитектуры рекомендуют 7±2 сервиса в одном домене

3. Энтропия ПО: 5+ примеров негэнтропийных мер
Энтропия ПО — мера беспорядка и хаотичности кодовой базы.

Негэнтропийные меры (борьба с хаосом):

Модульность:

Разделение на компоненты с четкими интерфейсами

Пример: Разделение на services, models, controllers

Принцип DRY (Don't Repeat Yourself):

Устранение дублирования через абстракции

Пример: Вынос общей логики в базовые классы

Паттерны проектирования:

Стандартные решения для типовых проблем

Пример: Использование Factory для создания объектов

Стиль кодирования:

Единые правила оформления кода

Пример: PEP 8 для Python, ESLint для JavaScript

Автоматизированное тестирование:

Поддержание порядка через тесты

Пример: Юнит-тесты для всех критических методов

CI/CD пайплайны:

Автоматизация сборки и деплоя

Пример: GitHub Actions с линтерами и тестами

Документация:

Поддержание актуальных docs/комментариев

Пример: Swagger для API, TypeScript типы как документация


4. 5 признаков сложной системы по Гради Бучу с примерами
Иерархическая структура:

Пример 1: Веб-приложение с клиентом, сервером, БД

Пример 2: Компилятор (лексер → парсер → генератор кода)

Относительная примитивность компонентов:

Пример 1: Микросервис "Аутентификация" с 3 методами

Пример 2: UI-компонент кнопки с базовыми пропсами

Разделение на подсистемы:

Пример 1: Backend/Frontend в e-commerce проекте

Пример 2: Модули auth, payments, inventory

Наличие связей между компонентами:

Пример 1: REST API между микросервисами

Пример 2: События между модулями через брокер (Kafka)

Целостность системы:

Пример 1: Единая БД для всех сервисов

Пример 2: Общий стиль для всех UI-компонентов

5. Закон иерархических компенсаций Седова: 5+ IT примеров
Закон: Развитие систем идет через создание иерархий, компенсирующих ограничения нижележащих уровней.

Исторические примеры:

Мэйнфреймы → ПК (1980-е):

Компенсация централизации распределенными системами

Пример: IBM System/360 → Apple II

Процедурное → ООП (1990-е):

Компенсация сложности управления состоянием

Пример: C → Java/C++

Монолиты → Микросервисы (2010-е):

Компенсация сложности масштабирования

Пример: eBay's переход в 2011

Ручное управление → Kubernetes:

Компенсация сложности оркестрации контейнеров

Пример: Docker Swarm → Kubernetes

SQL → NoSQL (2000-е):

Компенсация ограничений реляционных моделей

Пример: MySQL → MongoDB/Cassandra

Физические серверы → Облака:

Компенсация проблем с аппаратным обеспечением

Пример: AWS EC2 (2006)

Serverless архитектуры (2010-е):

Компенсация сложности управления серверами

Пример: AWS Lambda (2014)
